{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GALINI \u00b6 Getting Started \u00b6 Installation \u00b6 GALINI has not been released to Pypi yet. You will need to install it manually. The first step is to download GALINI source: git clone https://github.com/cog-imperial/galini.git GALINI requires a working installation of Ipopt to work. Refer to Ipopt documentation , set the IPOPT_INCLUDE_DIR and IPOPT_LIBRARY_DIR environment variables to Ipopt include and library directories respectively. You also need to update the LD_LIBRARY_PATH environment variable to include Ipopt library directory. After that, you should be able to install it with: python setup.py install And test everything is installed correctly with: python setup.py test Running \u00b6 To see the list of available commands run the galini command: $ galini usage: galini [-h] {dot,info,plugins,solve,special_structure} ... positional arguments: {dot,info,plugins,solve,special_structure} dot Save GALINI DAG of the problem as Graphviz Dot file info Print information about the problem plugins List registered plugins solve Solve a MINLP special_structure Print special structure information optional arguments: -h, --help show this help message and exit Output Format \u00b6 Most commands in GALINI have a flag to specify in which format to display the output: text : print output as text for human display json : print output as json, use it for data collection Troubleshooting \u00b6","title":"Home"},{"location":"#galini","text":"","title":"GALINI"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#installation","text":"GALINI has not been released to Pypi yet. You will need to install it manually. The first step is to download GALINI source: git clone https://github.com/cog-imperial/galini.git GALINI requires a working installation of Ipopt to work. Refer to Ipopt documentation , set the IPOPT_INCLUDE_DIR and IPOPT_LIBRARY_DIR environment variables to Ipopt include and library directories respectively. You also need to update the LD_LIBRARY_PATH environment variable to include Ipopt library directory. After that, you should be able to install it with: python setup.py install And test everything is installed correctly with: python setup.py test","title":"Installation"},{"location":"#running","text":"To see the list of available commands run the galini command: $ galini usage: galini [-h] {dot,info,plugins,solve,special_structure} ... positional arguments: {dot,info,plugins,solve,special_structure} dot Save GALINI DAG of the problem as Graphviz Dot file info Print information about the problem plugins List registered plugins solve Solve a MINLP special_structure Print special structure information optional arguments: -h, --help show this help message and exit","title":"Running"},{"location":"#output-format","text":"Most commands in GALINI have a flag to specify in which format to display the output: text : print output as text for human display json : print output as json, use it for data collection","title":"Output Format"},{"location":"#troubleshooting","text":"","title":"Troubleshooting"},{"location":"configuration/","text":"Configuration \u00b6 GALINI options can be customized by specifying a configuration file to use: galini solve --config /path/to/config.toml problem.py Example configuration \u00b6 This is an example configuration that you can use as reference for the most common options: [galini] paranoid_mode = true # activate paranoid mode timelimit=300 # solve time limit, in seconds integer_infinity = 100 # use this number as \"infinity\" for integer variables infinity = 1e8 # use this number as \"infinity\" for real variables user_upper_bound = 2e6 # user specified variables upper bound user_integer_upper_bound = 100 # user specified integer variables upper bound constraint_violation_tol=1e-5 # constraint violation tolerance fbbt_quadratic_max_terms = 100 # skip FBBT on quadratic expressions if they have more than this terms fbbt_linear_max_children = 100 # skip FBBT on linear expressions if they have more than this children fbbt_sum_max_children = 10 # skip FBBT on linear expressions if they have more than this children [branch_and_cut.cuts] maxiter = 100 # number of maximum iterations for cut phase loop use_lp_cut_phase = true # solve LP in cut phase use_milp_cut_phase = false # solve MILP in cut phase [branch_and_cut] tolerance=1e-6 # termination absolute tolerance relative_tolerance=1e-6 # termination relative tolerance fbbt_maxiter = 10 # maximum number of FBBT iterations at each node obbt_simplex_maxiter = 100 # maximum number of OBBT iterations catch_keyboard_interrupt = true # catch Ctrl-C and print solution. Disable to have raw stack traces root_node_feasible_solution_search_timelimit = 30 # time limit in seconds for search of feasible solution root_node_feasible_solution_seed = 42 # seed for feasible solution search obbt_timelimit = 60 # time limit in seconds for OBBT fbbt_timelimit = 20 # time limit in seconds for FBBT [mip.cplex] # pass \"raw\" options to CPLEX. 'preprocessing.reduce' = 0 'simplex.perturbation.constant' = 0.9999 [ipopt.ipopt] # pass \"raw\" options to Ipopt. tol = 1e-16 max_iter = 500 print_user_options = 'yes' [ipopt.logging] # pass \"raw\" options to Ipopt logging configuration. level = 'J_MOREDETAILED' [logging] stdout = false # print to standard out level = 'DEBUG' # log level: DEBUG, INFO, WARNING, ERROR directory = 'runout/test' # directory containing rich logging. If not set, disable it [cuts_generator] # specify which cut generators to use generators = ['triangle', 'outer_approximation', 'sdp'] [cuts_generator.triangle] # cuts generator specific options domain_eps = 1e-2","title":"Configuration"},{"location":"configuration/#configuration","text":"GALINI options can be customized by specifying a configuration file to use: galini solve --config /path/to/config.toml problem.py","title":"Configuration"},{"location":"configuration/#example-configuration","text":"This is an example configuration that you can use as reference for the most common options: [galini] paranoid_mode = true # activate paranoid mode timelimit=300 # solve time limit, in seconds integer_infinity = 100 # use this number as \"infinity\" for integer variables infinity = 1e8 # use this number as \"infinity\" for real variables user_upper_bound = 2e6 # user specified variables upper bound user_integer_upper_bound = 100 # user specified integer variables upper bound constraint_violation_tol=1e-5 # constraint violation tolerance fbbt_quadratic_max_terms = 100 # skip FBBT on quadratic expressions if they have more than this terms fbbt_linear_max_children = 100 # skip FBBT on linear expressions if they have more than this children fbbt_sum_max_children = 10 # skip FBBT on linear expressions if they have more than this children [branch_and_cut.cuts] maxiter = 100 # number of maximum iterations for cut phase loop use_lp_cut_phase = true # solve LP in cut phase use_milp_cut_phase = false # solve MILP in cut phase [branch_and_cut] tolerance=1e-6 # termination absolute tolerance relative_tolerance=1e-6 # termination relative tolerance fbbt_maxiter = 10 # maximum number of FBBT iterations at each node obbt_simplex_maxiter = 100 # maximum number of OBBT iterations catch_keyboard_interrupt = true # catch Ctrl-C and print solution. Disable to have raw stack traces root_node_feasible_solution_search_timelimit = 30 # time limit in seconds for search of feasible solution root_node_feasible_solution_seed = 42 # seed for feasible solution search obbt_timelimit = 60 # time limit in seconds for OBBT fbbt_timelimit = 20 # time limit in seconds for FBBT [mip.cplex] # pass \"raw\" options to CPLEX. 'preprocessing.reduce' = 0 'simplex.perturbation.constant' = 0.9999 [ipopt.ipopt] # pass \"raw\" options to Ipopt. tol = 1e-16 max_iter = 500 print_user_options = 'yes' [ipopt.logging] # pass \"raw\" options to Ipopt logging configuration. level = 'J_MOREDETAILED' [logging] stdout = false # print to standard out level = 'DEBUG' # log level: DEBUG, INFO, WARNING, ERROR directory = 'runout/test' # directory containing rich logging. If not set, disable it [cuts_generator] # specify which cut generators to use generators = ['triangle', 'outer_approximation', 'sdp'] [cuts_generator.triangle] # cuts generator specific options domain_eps = 1e-2","title":"Example configuration"},{"location":"expression_relaxations/","text":"Expression Relaxations \u00b6 Bilinear Terms \u00b6 Given the bilinear term xy xy over the domain [x^L, x^U] \\times [y^L, y^U] [x^L, x^U] \\times [y^L, y^U] , a convex underestimator by introducing a new variable w w that satisfies the following relationship: w = \\max{\\{x^L y + y^L x - x^L y^L; x^U y + y^U x - x^U y^U\\}} w = \\max{\\{x^L y + y^L x - x^L y^L; x^U y + y^U x - x^U y^U\\}} This expression can be included in the minimization problem as [1]: \\begin{align} w \\geq & x^Ly + y^Lx -x^Ly^L \\\\ w \\geq & x^Uy + y^Ux - x^Uy^U \\\\ w \\geq & x^Uy + y^Lx - x^Uy^L \\\\ w \\geq & x^Ly + y^Ux - x^Ly^U \\end{align} \\begin{align} w \\geq & x^Ly + y^Lx -x^Ly^L \\\\ w \\geq & x^Uy + y^Ux - x^Uy^U \\\\ w \\geq & x^Uy + y^Lx - x^Uy^L \\\\ w \\geq & x^Ly + y^Ux - x^Ly^U \\end{align} aBB Underestimator \u00b6 Given a nonconvex expression f(x) f(x) , a convex underestimator \\ell(x) \\ell(x) can be defined as [2]: \\ell(x) = f(x) + \\sum_i \\alpha_i (x_i^L - x_i)(x_i^U - x_i) \\ell(x) = f(x) + \\sum_i \\alpha_i (x_i^L - x_i)(x_i^U - x_i) where \\alpha_i \\geq \\max{\\{0, -\\frac{1}{2} \\min_{x} \\lambda(x) \\}} \\alpha_i \\geq \\max{\\{0, -\\frac{1}{2} \\min_{x} \\lambda(x) \\}} where \\lambda(x) \\lambda(x) are the eigenvalues of the Hessian matrix of f(x) f(x) . References \u00b6 [1] McCormick, G. P. (1976). Computability of global solutions to factorable nonconvex programs: Part I \u2014 Convex underestimating problems. Mathematical Programming, 10(1), 147\u2013175. https://doi.org/10.1007/BF01580665 [2] Androulakis, I. P., Maranas, C. D., & Floudas, C. A. (1995). \u03b1BB: A global optimization method for general constrained nonconvex problems. Journal of Global Optimization, 7(4), 337\u2013363. https://doi.org/10.1007/BF01099647","title":"Expression Relaxations"},{"location":"expression_relaxations/#expression-relaxations","text":"","title":"Expression Relaxations"},{"location":"expression_relaxations/#bilinear-terms","text":"Given the bilinear term xy xy over the domain [x^L, x^U] \\times [y^L, y^U] [x^L, x^U] \\times [y^L, y^U] , a convex underestimator by introducing a new variable w w that satisfies the following relationship: w = \\max{\\{x^L y + y^L x - x^L y^L; x^U y + y^U x - x^U y^U\\}} w = \\max{\\{x^L y + y^L x - x^L y^L; x^U y + y^U x - x^U y^U\\}} This expression can be included in the minimization problem as [1]: \\begin{align} w \\geq & x^Ly + y^Lx -x^Ly^L \\\\ w \\geq & x^Uy + y^Ux - x^Uy^U \\\\ w \\geq & x^Uy + y^Lx - x^Uy^L \\\\ w \\geq & x^Ly + y^Ux - x^Ly^U \\end{align} \\begin{align} w \\geq & x^Ly + y^Lx -x^Ly^L \\\\ w \\geq & x^Uy + y^Ux - x^Uy^U \\\\ w \\geq & x^Uy + y^Lx - x^Uy^L \\\\ w \\geq & x^Ly + y^Ux - x^Ly^U \\end{align}","title":"Bilinear Terms"},{"location":"expression_relaxations/#abb-underestimator","text":"Given a nonconvex expression f(x) f(x) , a convex underestimator \\ell(x) \\ell(x) can be defined as [2]: \\ell(x) = f(x) + \\sum_i \\alpha_i (x_i^L - x_i)(x_i^U - x_i) \\ell(x) = f(x) + \\sum_i \\alpha_i (x_i^L - x_i)(x_i^U - x_i) where \\alpha_i \\geq \\max{\\{0, -\\frac{1}{2} \\min_{x} \\lambda(x) \\}} \\alpha_i \\geq \\max{\\{0, -\\frac{1}{2} \\min_{x} \\lambda(x) \\}} where \\lambda(x) \\lambda(x) are the eigenvalues of the Hessian matrix of f(x) f(x) .","title":"aBB Underestimator"},{"location":"expression_relaxations/#references","text":"[1] McCormick, G. P. (1976). Computability of global solutions to factorable nonconvex programs: Part I \u2014 Convex underestimating problems. Mathematical Programming, 10(1), 147\u2013175. https://doi.org/10.1007/BF01580665 [2] Androulakis, I. P., Maranas, C. D., & Floudas, C. A. (1995). \u03b1BB: A global optimization method for general constrained nonconvex problems. Journal of Global Optimization, 7(4), 337\u2013363. https://doi.org/10.1007/BF01099647","title":"References"},{"location":"installation/","text":"Installation \u00b6 Requirements \u00b6 To build GALINI you need: A recent version of pybind11 Coramin CPLEX Ipopt Installation \u00b6 Start by installing pybind11 using pip. We recommend using a virtual environment to install GALINI. To create a virtual environment using anaconda : conda create -n galini python=3.5 conda activate galini Then install pybind11: pip install pybind11 Install Coramin and its dependencies: git clone git@github.com:Coramin/Coramin.git cd Coramin pip install pyomo scipy numpy python setup.py install You need to install Ipopt, you can find more details on the Coin OR website. You also need to install CPLEX and its python library. If you installed CPLEX in /opt/cplex then: cd /opt/cplex/python/3.6/x86-64_linux python3 setup.py install Create a local clone of GALINI: git clone https://github.com/cog-imperial/galini.git You need to set two environment variables to point to Ipopt include and library directories: IPOPT_INCLUDE_DIR=/path/to/ipopt/include IPOPT_LIBRARY_DIR=/path/to/ipopt/lib After that, you can build and install GALINI: cd /path/to/galini python setup.py build python setup.py install Check installation \u00b6 You can check that evereything was installed correctly by running GALINI without any arguments: $ galini usage: galini [-h] {abb,dot,info,plugins,solve,special_structure} ... positional arguments: {abb,dot,info,plugins,solve,special_structure} abb Save GALINI DAG of the problem as Graphviz Dot file dot Save GALINI DAG of the problem as Graphviz Dot file info Print information about the problem plugins List registered plugins solve Solve a MINLP special_structure Print special structure information optional arguments: -h, --help show this help message and exit","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#requirements","text":"To build GALINI you need: A recent version of pybind11 Coramin CPLEX Ipopt","title":"Requirements"},{"location":"installation/#installation_1","text":"Start by installing pybind11 using pip. We recommend using a virtual environment to install GALINI. To create a virtual environment using anaconda : conda create -n galini python=3.5 conda activate galini Then install pybind11: pip install pybind11 Install Coramin and its dependencies: git clone git@github.com:Coramin/Coramin.git cd Coramin pip install pyomo scipy numpy python setup.py install You need to install Ipopt, you can find more details on the Coin OR website. You also need to install CPLEX and its python library. If you installed CPLEX in /opt/cplex then: cd /opt/cplex/python/3.6/x86-64_linux python3 setup.py install Create a local clone of GALINI: git clone https://github.com/cog-imperial/galini.git You need to set two environment variables to point to Ipopt include and library directories: IPOPT_INCLUDE_DIR=/path/to/ipopt/include IPOPT_LIBRARY_DIR=/path/to/ipopt/lib After that, you can build and install GALINI: cd /path/to/galini python setup.py build python setup.py install","title":"Installation"},{"location":"installation/#check-installation","text":"You can check that evereything was installed correctly by running GALINI without any arguments: $ galini usage: galini [-h] {abb,dot,info,plugins,solve,special_structure} ... positional arguments: {abb,dot,info,plugins,solve,special_structure} abb Save GALINI DAG of the problem as Graphviz Dot file dot Save GALINI DAG of the problem as Graphviz Dot file info Print information about the problem plugins List registered plugins solve Solve a MINLP special_structure Print special structure information optional arguments: -h, --help show this help message and exit","title":"Check installation"},{"location":"logging/","text":"","title":"Logging"},{"location":"relaxations/","text":"Developing Relaxations \u00b6 GALINI provides an intuitive interface to develop relaxations. All you have to do is implement the Relaxation interface from galini.relaxations . This interface requires you to implement two methods: can_relax and relax . The first method takes a problem, expression and context in input and returns a boolean value to indicate whether the current relaxation can relax the given expression. The second method takes the same problem, expression and context as the previous one and returns a RelaxationResult . A RelaxationResult is an object that contains a new expression and constraints. The old expression will be replaced by the new expression, and the constraints will be added to the problem.","title":"Relaxations"},{"location":"relaxations/#developing-relaxations","text":"GALINI provides an intuitive interface to develop relaxations. All you have to do is implement the Relaxation interface from galini.relaxations . This interface requires you to implement two methods: can_relax and relax . The first method takes a problem, expression and context in input and returns a boolean value to indicate whether the current relaxation can relax the given expression. The second method takes the same problem, expression and context as the previous one and returns a RelaxationResult . A RelaxationResult is an object that contains a new expression and constraints. The old expression will be replaced by the new expression, and the constraints will be added to the problem.","title":"Developing Relaxations"},{"location":"bab/branching/","text":"Branching Strategies \u00b6 You can pass a branching strategy to a B&B node to decide on which variable to branch. Four alternatives implemented [1]: K-section Maximum separation distance between underestimator and term Separation distance at optimum Influence of each variable on the quality of the lower bounding problem K-section \u00b6 Pick the least reduced axis , that is the axis with the largest r_i r_i defined as: r_i = \\frac{x_i^U - x_i^L}{x_{i,0}^U - x_{i,0}^L} r_i = \\frac{x_i^U - x_i^L}{x_{i,0}^U - x_{i,0}^L} where x_i^U x_i^U and x_i^L x_i^L are x_i x_i bounds at the current node, and x_{i,0}^U x_{i,0}^U and x_{i,0}^L x_{i,0}^L are the bounds at the root node. Maximum separation distance 1 \u00b6 We define a new measure \\mu \\mu to asses the quality of the underestimator. For a bilinear term xy xy , the maximum separation distance was derived by [2] so that \\mu_b \\mu_b is: \\mu_b = \\frac{1}{4}(x^U - x^L)(y^U - y^L) \\mu_b = \\frac{1}{4}(x^U - x^L)(y^U - y^L) The term with the worst underestimator is used as the basis for the branching variable. Out of the variables that participate in the term, the one with the least reduced axis r_i r_i is picked. Maximum separation distance 1 \u00b6 This strategy is a variation of the previous one. We compute the maximum separation distance at the optimum. Influence of each variable on the quality of the lower bounding problem \u00b6 This branching strategy considers the influence of each variable on the convex problem. After the quantities \\mu \\mu have been computed for each term, a measure \\mu_v \\mu_v of each variable contribution is defined as the sum of quantities \\mu \\mu in which the variable participates. Reference \u00b6 [1] Adjiman, C. S., Androulakis, I. P., & Floudas, C. A. (1998). A global optimization method, \u03b1BB, for general twice-differentiable constrained NLPs\u2014II. Implementation and computational results. Computers & Chemical Engineering, 22(9), 1159\u20131179. https://doi.org/10.1016/S0098-1354(98)00218-Xs [2] Androulakis, I. P., Maranas, C. D., & Floudas, C. A. (1995). \u03b1BB: A global optimization method for general constrained nonconvex problems. Journal of Global Optimization, 7(4), 337\u2013363. https://doi.org/10.1007/BF01099647","title":"Branching"},{"location":"bab/branching/#branching-strategies","text":"You can pass a branching strategy to a B&B node to decide on which variable to branch. Four alternatives implemented [1]: K-section Maximum separation distance between underestimator and term Separation distance at optimum Influence of each variable on the quality of the lower bounding problem","title":"Branching Strategies"},{"location":"bab/branching/#k-section","text":"Pick the least reduced axis , that is the axis with the largest r_i r_i defined as: r_i = \\frac{x_i^U - x_i^L}{x_{i,0}^U - x_{i,0}^L} r_i = \\frac{x_i^U - x_i^L}{x_{i,0}^U - x_{i,0}^L} where x_i^U x_i^U and x_i^L x_i^L are x_i x_i bounds at the current node, and x_{i,0}^U x_{i,0}^U and x_{i,0}^L x_{i,0}^L are the bounds at the root node.","title":"K-section"},{"location":"bab/branching/#maximum-separation-distance-1","text":"We define a new measure \\mu \\mu to asses the quality of the underestimator. For a bilinear term xy xy , the maximum separation distance was derived by [2] so that \\mu_b \\mu_b is: \\mu_b = \\frac{1}{4}(x^U - x^L)(y^U - y^L) \\mu_b = \\frac{1}{4}(x^U - x^L)(y^U - y^L) The term with the worst underestimator is used as the basis for the branching variable. Out of the variables that participate in the term, the one with the least reduced axis r_i r_i is picked.","title":"Maximum separation distance 1"},{"location":"bab/branching/#maximum-separation-distance-1_1","text":"This strategy is a variation of the previous one. We compute the maximum separation distance at the optimum.","title":"Maximum separation distance 1"},{"location":"bab/branching/#influence-of-each-variable-on-the-quality-of-the-lower-bounding-problem","text":"This branching strategy considers the influence of each variable on the convex problem. After the quantities \\mu \\mu have been computed for each term, a measure \\mu_v \\mu_v of each variable contribution is defined as the sum of quantities \\mu \\mu in which the variable participates.","title":"Influence of each variable on the quality of the lower bounding problem"},{"location":"bab/branching/#reference","text":"[1] Adjiman, C. S., Androulakis, I. P., & Floudas, C. A. (1998). A global optimization method, \u03b1BB, for general twice-differentiable constrained NLPs\u2014II. Implementation and computational results. Computers & Chemical Engineering, 22(9), 1159\u20131179. https://doi.org/10.1016/S0098-1354(98)00218-Xs [2] Androulakis, I. P., Maranas, C. D., & Floudas, C. A. (1995). \u03b1BB: A global optimization method for general constrained nonconvex problems. Journal of Global Optimization, 7(4), 337\u2013363. https://doi.org/10.1007/BF01099647","title":"Reference"},{"location":"bab/tree/","text":"Tree & Nodes \u00b6","title":"Tree & Nodes"},{"location":"bab/tree/#tree-nodes","text":"","title":"Tree &amp; Nodes"},{"location":"branch_and_cut/algorithm/","text":"Branch & Cut Algorithm \u00b6 GALINI Branch & Cut algorithm is implemented in the galini.branch_and_cut module. The main classes are: BranchAndCutSolver : implements the solver interface and is responsible for initializing GALINI and managing the high level branch & bound process. BranchAndCutAlgorithm : solves the problem at each branch & bound node. NodeStorage : defines the data that is stored at each branch & bound node. Telemetry : defines the counters that are updated and logged at each branch & bound node. Branch & Bound Overview \u00b6 The algorithm is as follows, using Python-like pseudo-code: def branch_and_bound ( problem ): tree = initialize_tree ( problem ) algorithm = initialize_algorithm ( tree , problem ) root_lower_bound , root_upper_bound = algorithm . solve_root_problem ( problem ) # Set tree best lower and upper bounds tree . update_state ( root_lower_bound , root_upper_bound ) while not should_terminate (): if not tree . has_nodes (): # Terminate: explored all nodes break current_node = tree . next_node () if current_node . parent . lower_bound >= best_upper_bound : # The node can't produce a better feasible solution than # the current best feasible solution. continue node_lower_bound , node_upper_bound = \\ algorithm . solve_problem ( current_node , problem ) # Update tree lower and upper bounds tree . update_state ( node_lower_bound , node_upper_bound ) if is_close ( node_lower_bound , node_upper_bound ): # Node converged and there is no need to continue branching in # this part of the tree. continue # Branch at node to continue exploring tree . branch_at_node ( current_node ) The function should_terminate controls if the algorithm should continue exploring the branch & bound nodes or terminate. This function checks for: Convergence of the tree lower and upper bounds Termination based on the user-defined time limit Termination based on the user-defined node limit Branch & bound tree \u00b6 At the center of the branch & bound algorithm there are the Tree and Node classes. The Tree class can be customized to use user-provided branching and node selection strategies. The Tree class is initialized with a root node that contains the original instance of the problem (with the original problem bounds). After solving the problem at the root node, the algorithm branches on one or more variables at one or more points to create multiple children nodes. The non-root nodes don't store the entire problem, instead they only store the variables bounds at the node and a pointer to the parent problem. When nodes are first created, they are marked as not visited and added to the queue of nodes to be visited. At each iteration of the branch & bound loop, the algorithm pops the most promising node from the queue and solves the node problem. The solution at the node is used to update the node state (global lower and upper bounds). The tree upper bound is the best (lowest) feasible solution found so far, the function to update the tree upper bound is as follows: def update_tree_upper_bound ( tree , candidate_solution ): if not candidate_solution . is_feasible : return tree . upper_bound = min ( candidate_solution . objective_value , tree . upper_bound , ) The tree lower bound is the lowest of the open nodes lower bounds, that is the solution of the linear relaxation of the problem. Since open nodes have not been solved (by definition), then we consider their parent lower bound as their lower bound. If there are no open nodes, then we consider the lower bounds of phatomed nodes. def update_tree_lower_bound ( tree , candidate_solution ): if not candidate_solution . is_feasible : return best_lower_bound = infinity for node in tree . open_nodes : node_lower_bound = node . parent . lower_bound if node_lower_bound < best_lower_bound : best_lower_bound = node_lower_bound if best_lower_bound != infinity : # The lower bound was updated from open nodes. Finished. tree . lower_bound = best_lower_bound return for node in tree . phatomed_nodes : node_lower_bound = node . parent . lower_bound if node_lower_bound < best_lower_bound : best_lower_bound = node_lower_bound # Update lower bound. tree . lower_bound = best_lower_bound Cut Loop \u00b6 The Branch & Cut algorithm solves the problems at each node of the branch & bound loop by relaxing the problem to a LP and generating cutting planes. The behaviour of the cut loop can be controlled by changing the configuration. The algorithm starts by trying to find a feasible solution as soon as possible. After this, it starts a cut loop phase where it solves a series of LPs. At the beginning of the cut loop, the algorithm solves the LP and then iterates over the node parent cuts, adding any violated cut. It repeats this step until there are no more violated cuts. After this, the algorithm solves a series of LPs and calls the cuts generator to generate new cuts that are added to the problem and the cut pool. This step is repeated until: All the cuts generators cannot generate any more cuts The maximum number of iterations is exceeded If the appropriate flag is set, the cut loop is repeated again, this time by solving a series of MILPs. After the cut phases are finished, GALINI checks if the current node can produce a better feasible solution by comparing the linear relaxation solution to the tree upper bound. Finally, the algorithm solves the original problem to find a feasible solution. The heuristic used to find a feasible solution fixes all integer variables to the values found in cut phase and then uses a NLP solver to find a (local) solution to the problem. def solve_problem_at_node ( tree , node , problem ): convex_problem = relax_problem_to_convex ( problem ) linear_problem = relax_problem_to_linear ( convex_problem ) feasible_solution = try_find_feasible_solution ( problem ) if options . lp_cut_loop_active : relax_integral_variables ( linear_problem ) lower_bound_solution = perform_cut_loop ( node , convex_problem , linear_problem ) restore_integral_variables ( linear_problem ) if options . milp_cut_loop_active : lower_bound_solution = perform_cut_loop ( node , convex_problem , linear_problem ) if tree . upper_bound < lower_bound_solution . objective_value : # The node will not provide an improvement, don't solve primal. return lower_bound_solution , None upper_bound_solution = solve ( problem , starting_point = lower_bound_solution ) return lower_bound_solution , upper_bound_solution The cut loop is the same whether GALINI is solving a MILP or a LP. def perform_cut_loop ( node , convex_problem , linear_problem ): if node . parent : add_cuts_from_parent ( node . parent , linear_problem ) while not cut_loop_should_terminate (): solution = solve ( linear_problem ) new_cuts = generate_cuts ( convex_problem , linear_problem , solution ) for cut in new_cuts : # Add cut to the cut pool and the linear problem node . cut_pool . add_cut ( cut ) linear_problem . add_cut ( cut )","title":"Algorithm"},{"location":"branch_and_cut/algorithm/#branch-cut-algorithm","text":"GALINI Branch & Cut algorithm is implemented in the galini.branch_and_cut module. The main classes are: BranchAndCutSolver : implements the solver interface and is responsible for initializing GALINI and managing the high level branch & bound process. BranchAndCutAlgorithm : solves the problem at each branch & bound node. NodeStorage : defines the data that is stored at each branch & bound node. Telemetry : defines the counters that are updated and logged at each branch & bound node.","title":"Branch &amp; Cut Algorithm"},{"location":"branch_and_cut/algorithm/#branch-bound-overview","text":"The algorithm is as follows, using Python-like pseudo-code: def branch_and_bound ( problem ): tree = initialize_tree ( problem ) algorithm = initialize_algorithm ( tree , problem ) root_lower_bound , root_upper_bound = algorithm . solve_root_problem ( problem ) # Set tree best lower and upper bounds tree . update_state ( root_lower_bound , root_upper_bound ) while not should_terminate (): if not tree . has_nodes (): # Terminate: explored all nodes break current_node = tree . next_node () if current_node . parent . lower_bound >= best_upper_bound : # The node can't produce a better feasible solution than # the current best feasible solution. continue node_lower_bound , node_upper_bound = \\ algorithm . solve_problem ( current_node , problem ) # Update tree lower and upper bounds tree . update_state ( node_lower_bound , node_upper_bound ) if is_close ( node_lower_bound , node_upper_bound ): # Node converged and there is no need to continue branching in # this part of the tree. continue # Branch at node to continue exploring tree . branch_at_node ( current_node ) The function should_terminate controls if the algorithm should continue exploring the branch & bound nodes or terminate. This function checks for: Convergence of the tree lower and upper bounds Termination based on the user-defined time limit Termination based on the user-defined node limit","title":"Branch &amp; Bound Overview"},{"location":"branch_and_cut/algorithm/#branch-bound-tree","text":"At the center of the branch & bound algorithm there are the Tree and Node classes. The Tree class can be customized to use user-provided branching and node selection strategies. The Tree class is initialized with a root node that contains the original instance of the problem (with the original problem bounds). After solving the problem at the root node, the algorithm branches on one or more variables at one or more points to create multiple children nodes. The non-root nodes don't store the entire problem, instead they only store the variables bounds at the node and a pointer to the parent problem. When nodes are first created, they are marked as not visited and added to the queue of nodes to be visited. At each iteration of the branch & bound loop, the algorithm pops the most promising node from the queue and solves the node problem. The solution at the node is used to update the node state (global lower and upper bounds). The tree upper bound is the best (lowest) feasible solution found so far, the function to update the tree upper bound is as follows: def update_tree_upper_bound ( tree , candidate_solution ): if not candidate_solution . is_feasible : return tree . upper_bound = min ( candidate_solution . objective_value , tree . upper_bound , ) The tree lower bound is the lowest of the open nodes lower bounds, that is the solution of the linear relaxation of the problem. Since open nodes have not been solved (by definition), then we consider their parent lower bound as their lower bound. If there are no open nodes, then we consider the lower bounds of phatomed nodes. def update_tree_lower_bound ( tree , candidate_solution ): if not candidate_solution . is_feasible : return best_lower_bound = infinity for node in tree . open_nodes : node_lower_bound = node . parent . lower_bound if node_lower_bound < best_lower_bound : best_lower_bound = node_lower_bound if best_lower_bound != infinity : # The lower bound was updated from open nodes. Finished. tree . lower_bound = best_lower_bound return for node in tree . phatomed_nodes : node_lower_bound = node . parent . lower_bound if node_lower_bound < best_lower_bound : best_lower_bound = node_lower_bound # Update lower bound. tree . lower_bound = best_lower_bound","title":"Branch &amp; bound tree"},{"location":"branch_and_cut/algorithm/#cut-loop","text":"The Branch & Cut algorithm solves the problems at each node of the branch & bound loop by relaxing the problem to a LP and generating cutting planes. The behaviour of the cut loop can be controlled by changing the configuration. The algorithm starts by trying to find a feasible solution as soon as possible. After this, it starts a cut loop phase where it solves a series of LPs. At the beginning of the cut loop, the algorithm solves the LP and then iterates over the node parent cuts, adding any violated cut. It repeats this step until there are no more violated cuts. After this, the algorithm solves a series of LPs and calls the cuts generator to generate new cuts that are added to the problem and the cut pool. This step is repeated until: All the cuts generators cannot generate any more cuts The maximum number of iterations is exceeded If the appropriate flag is set, the cut loop is repeated again, this time by solving a series of MILPs. After the cut phases are finished, GALINI checks if the current node can produce a better feasible solution by comparing the linear relaxation solution to the tree upper bound. Finally, the algorithm solves the original problem to find a feasible solution. The heuristic used to find a feasible solution fixes all integer variables to the values found in cut phase and then uses a NLP solver to find a (local) solution to the problem. def solve_problem_at_node ( tree , node , problem ): convex_problem = relax_problem_to_convex ( problem ) linear_problem = relax_problem_to_linear ( convex_problem ) feasible_solution = try_find_feasible_solution ( problem ) if options . lp_cut_loop_active : relax_integral_variables ( linear_problem ) lower_bound_solution = perform_cut_loop ( node , convex_problem , linear_problem ) restore_integral_variables ( linear_problem ) if options . milp_cut_loop_active : lower_bound_solution = perform_cut_loop ( node , convex_problem , linear_problem ) if tree . upper_bound < lower_bound_solution . objective_value : # The node will not provide an improvement, don't solve primal. return lower_bound_solution , None upper_bound_solution = solve ( problem , starting_point = lower_bound_solution ) return lower_bound_solution , upper_bound_solution The cut loop is the same whether GALINI is solving a MILP or a LP. def perform_cut_loop ( node , convex_problem , linear_problem ): if node . parent : add_cuts_from_parent ( node . parent , linear_problem ) while not cut_loop_should_terminate (): solution = solve ( linear_problem ) new_cuts = generate_cuts ( convex_problem , linear_problem , solution ) for cut in new_cuts : # Add cut to the cut pool and the linear problem node . cut_pool . add_cut ( cut ) linear_problem . add_cut ( cut )","title":"Cut Loop"},{"location":"branch_and_cut/api/","text":"API Reference \u00b6 Cuts generator interface. Cut \u00b6 Represent a cut to be added to the problem. index : _empty (property, writable) \u00b6 Get cut index in cut pool. is_global : _empty (property, readonly) \u00b6 Return True if cut is global. is_local : _empty (property, readonly) \u00b6 Return True if cut is local. CutsGenerator \u00b6 CutsGenerator interface. after_end_at_node ( self , run_id , problem , relaxed_problem , solution ) \u00b6 Show source code in galini/cuts/generator.py 107 108 109 110 111 112 113 114 115 116 117 118 119 def after_end_at_node ( self , run_id , problem , relaxed_problem , solution ): \"\"\"Called after the cut loop at any non-root node. Args: run_id: current run id problem: the user problem relaxed_problem: the convex relaxation of problem solution: the solution after the cut loop terminated Returns: None \"\"\" pass Called after the cut loop at any non-root node. Parameters Name Type Description Default run_id _empty current run id required problem _empty the user problem required relaxed_problem _empty the convex relaxation of problem required solution _empty the solution after the cut loop terminated required Returns Type Description _empty None after_end_at_root ( self , run_id , problem , relaxed_problem , solution ) \u00b6 Show source code in galini/cuts/generator.py 80 81 82 83 84 85 86 87 88 89 90 91 92 def after_end_at_root ( self , run_id , problem , relaxed_problem , solution ): \"\"\"Called after the cut loop at root node. Args: run_id: current run id problem: the user problem relaxed_problem: the convex relaxation of problem solution: the solution after the cut loop terminated Returns: None \"\"\" pass Called after the cut loop at root node. Parameters Name Type Description Default run_id _empty current run id required problem _empty the user problem required relaxed_problem _empty the convex relaxation of problem required solution _empty the solution after the cut loop terminated required Returns Type Description _empty None before_start_at_node ( self , run_id , problem , relaxed_problem ) \u00b6 Show source code in galini/cuts/generator.py 94 95 96 97 98 99 100 101 102 103 104 105 def before_start_at_node ( self , run_id , problem , relaxed_problem ): \"\"\"Called before the cut loop starts at any non-root node. Args: run_id: current run id problem: the user problem relaxed_problem: the convex relaxation of problem Returns: None \"\"\" pass Called before the cut loop starts at any non-root node. Parameters Name Type Description Default run_id _empty current run id required problem _empty the user problem required relaxed_problem _empty the convex relaxation of problem required Returns Type Description _empty None before_start_at_root ( self , run_id , problem , relaxed_problem ) \u00b6 Show source code in galini/cuts/generator.py 67 68 69 70 71 72 73 74 75 76 77 78 def before_start_at_root ( self , run_id , problem , relaxed_problem ): \"\"\"Called before the cut loop starts at root node. Args: run_id: current run id problem: the user problem relaxed_problem: the convex relaxation of problem Returns: None \"\"\" pass Called before the cut loop starts at root node. Parameters Name Type Description Default run_id _empty current run id required problem _empty the user problem required relaxed_problem _empty the convex relaxation of problem required Returns Type Description _empty None generate ( self , run_id , problem , relaxed_problem , linear_problem , mip_solution , tree , node ) \u00b6 Show source code in galini/cuts/generator.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @abc.abstractmethod def generate ( self , run_id , problem , relaxed_problem , linear_problem , mip_solution , tree , node ): \"\"\"Generate new cuts. Args: run_id: current run id problem: the user problem relaxed_problem: the convex relaxation of problem linear_problem: the linearization of relaxed_problem mip_solution: the previous cut loop iteration solution tree: the branch and bound tree node: the current branch and bound node Returns: a list of [cuts][galini.cuts.generator.Cut] or `None` \"\"\" pass Generate new cuts. Parameters Name Type Description Default run_id _empty current run id required problem _empty the user problem required relaxed_problem _empty the convex relaxation of problem required linear_problem _empty the linearization of relaxed_problem required mip_solution _empty the previous cut loop iteration solution required tree _empty the branch and bound tree required node _empty the current branch and bound node required Returns Type Description _empty a list of cuts or None has_converged ( self , state ) \u00b6 Show source code in galini/cuts/generator.py 121 122 123 124 125 126 127 128 129 130 131 def has_converged ( self , state ): \"\"\"Predicate that returns `True` if the cut generator finished generating cuts. Args: state: the cut state Returns: `True` if the cut generator finished generating cuts \"\"\" pass Predicate that returns True if the cut generator finished generating cuts. Parameters Name Type Description Default state _empty the cut state required Returns Type Description _empty True if the cut generator finished generating cuts CutType \u00b6 An enumeration.","title":"API Reference"},{"location":"branch_and_cut/api/#api-reference","text":"Cuts generator interface.","title":"API Reference"},{"location":"branch_and_cut/api/#galini.cuts.generator.Cut","text":"Represent a cut to be added to the problem.","title":"Cut"},{"location":"branch_and_cut/api/#galini.cuts.generator.Cut.index","text":"Get cut index in cut pool.","title":"index: _empty (property, writable)"},{"location":"branch_and_cut/api/#galini.cuts.generator.Cut.is_global","text":"Return True if cut is global.","title":"is_global: _empty (property, readonly)"},{"location":"branch_and_cut/api/#galini.cuts.generator.Cut.is_local","text":"Return True if cut is local.","title":"is_local: _empty (property, readonly)"},{"location":"branch_and_cut/api/#galini.cuts.generator.CutsGenerator","text":"CutsGenerator interface.","title":"CutsGenerator"},{"location":"branch_and_cut/api/#galini.cuts.generator.CutsGenerator.after_end_at_node","text":"Show source code in galini/cuts/generator.py 107 108 109 110 111 112 113 114 115 116 117 118 119 def after_end_at_node ( self , run_id , problem , relaxed_problem , solution ): \"\"\"Called after the cut loop at any non-root node. Args: run_id: current run id problem: the user problem relaxed_problem: the convex relaxation of problem solution: the solution after the cut loop terminated Returns: None \"\"\" pass Called after the cut loop at any non-root node. Parameters Name Type Description Default run_id _empty current run id required problem _empty the user problem required relaxed_problem _empty the convex relaxation of problem required solution _empty the solution after the cut loop terminated required Returns Type Description _empty None","title":"after_end_at_node(self, run_id, problem, relaxed_problem, solution)"},{"location":"branch_and_cut/api/#galini.cuts.generator.CutsGenerator.after_end_at_root","text":"Show source code in galini/cuts/generator.py 80 81 82 83 84 85 86 87 88 89 90 91 92 def after_end_at_root ( self , run_id , problem , relaxed_problem , solution ): \"\"\"Called after the cut loop at root node. Args: run_id: current run id problem: the user problem relaxed_problem: the convex relaxation of problem solution: the solution after the cut loop terminated Returns: None \"\"\" pass Called after the cut loop at root node. Parameters Name Type Description Default run_id _empty current run id required problem _empty the user problem required relaxed_problem _empty the convex relaxation of problem required solution _empty the solution after the cut loop terminated required Returns Type Description _empty None","title":"after_end_at_root(self, run_id, problem, relaxed_problem, solution)"},{"location":"branch_and_cut/api/#galini.cuts.generator.CutsGenerator.before_start_at_node","text":"Show source code in galini/cuts/generator.py 94 95 96 97 98 99 100 101 102 103 104 105 def before_start_at_node ( self , run_id , problem , relaxed_problem ): \"\"\"Called before the cut loop starts at any non-root node. Args: run_id: current run id problem: the user problem relaxed_problem: the convex relaxation of problem Returns: None \"\"\" pass Called before the cut loop starts at any non-root node. Parameters Name Type Description Default run_id _empty current run id required problem _empty the user problem required relaxed_problem _empty the convex relaxation of problem required Returns Type Description _empty None","title":"before_start_at_node(self, run_id, problem, relaxed_problem)"},{"location":"branch_and_cut/api/#galini.cuts.generator.CutsGenerator.before_start_at_root","text":"Show source code in galini/cuts/generator.py 67 68 69 70 71 72 73 74 75 76 77 78 def before_start_at_root ( self , run_id , problem , relaxed_problem ): \"\"\"Called before the cut loop starts at root node. Args: run_id: current run id problem: the user problem relaxed_problem: the convex relaxation of problem Returns: None \"\"\" pass Called before the cut loop starts at root node. Parameters Name Type Description Default run_id _empty current run id required problem _empty the user problem required relaxed_problem _empty the convex relaxation of problem required Returns Type Description _empty None","title":"before_start_at_root(self, run_id, problem, relaxed_problem)"},{"location":"branch_and_cut/api/#galini.cuts.generator.CutsGenerator.generate","text":"Show source code in galini/cuts/generator.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @abc.abstractmethod def generate ( self , run_id , problem , relaxed_problem , linear_problem , mip_solution , tree , node ): \"\"\"Generate new cuts. Args: run_id: current run id problem: the user problem relaxed_problem: the convex relaxation of problem linear_problem: the linearization of relaxed_problem mip_solution: the previous cut loop iteration solution tree: the branch and bound tree node: the current branch and bound node Returns: a list of [cuts][galini.cuts.generator.Cut] or `None` \"\"\" pass Generate new cuts. Parameters Name Type Description Default run_id _empty current run id required problem _empty the user problem required relaxed_problem _empty the convex relaxation of problem required linear_problem _empty the linearization of relaxed_problem required mip_solution _empty the previous cut loop iteration solution required tree _empty the branch and bound tree required node _empty the current branch and bound node required Returns Type Description _empty a list of cuts or None","title":"generate(self, run_id, problem, relaxed_problem, linear_problem, mip_solution, tree, node)"},{"location":"branch_and_cut/api/#galini.cuts.generator.CutsGenerator.has_converged","text":"Show source code in galini/cuts/generator.py 121 122 123 124 125 126 127 128 129 130 131 def has_converged ( self , state ): \"\"\"Predicate that returns `True` if the cut generator finished generating cuts. Args: state: the cut state Returns: `True` if the cut generator finished generating cuts \"\"\" pass Predicate that returns True if the cut generator finished generating cuts. Parameters Name Type Description Default state _empty the cut state required Returns Type Description _empty True if the cut generator finished generating cuts","title":"has_converged(self, state)"},{"location":"branch_and_cut/api/#galini.cuts.generator.CutType","text":"An enumeration.","title":"CutType"},{"location":"branch_and_cut/cuts/","text":"Cut Generation & Cut Pool \u00b6 Cut Generation \u00b6 At every iteration of the cut loop, GALINI generates new cuts by delegating cut generation to cut generators . Cut generators implement the CutsGenerator interface. Cut Pool \u00b6 All cuts are stored in a cut pool . Before starting the cut loop at each branch and bound node, GALINI will go through valid cuts for that node and add any violated cuts. Cuts are considered valid for a node if they were generated by one of the node's parents.","title":"Cut Generation"},{"location":"branch_and_cut/cuts/#cut-generation-cut-pool","text":"","title":"Cut Generation &amp; Cut Pool"},{"location":"branch_and_cut/cuts/#cut-generation","text":"At every iteration of the cut loop, GALINI generates new cuts by delegating cut generation to cut generators . Cut generators implement the CutsGenerator interface.","title":"Cut Generation"},{"location":"branch_and_cut/cuts/#cut-pool","text":"All cuts are stored in a cut pool . Before starting the cut loop at each branch and bound node, GALINI will go through valid cuts for that node and add any violated cuts. Cuts are considered valid for a node if they were generated by one of the node's parents.","title":"Cut Pool"},{"location":"commands/dot/","text":"dot command \u00b6 GALINI provides a command to output a problem DAG to Graphviz DOT files. This is useful when debugging code that needs to traverse the DAG. Usage \u00b6 galini dot [-h] problem [out] Example \u00b6 Given the following input file problem.py import pyomo.environ as aml def get_pyomo_model (): m = aml . ConcreteModel () m . x = aml . Var ( range ( 2 ), bounds = ( 0 , 4.0 )) m . y = aml . Var ( range ( 2 ), bounds = ( 0 , 1 ), domain = aml . Integers ) m . obj = aml . Objective ( expr = m . y [ 0 ] + m . y [ 1 ] + m . x [ 0 ] ** 2 + m . x [ 1 ] ** 2 ) m . c0 = aml . Constraint ( expr = ( m . x [ 0 ] - 2 ) ** 2 - m . x [ 1 ] <= 0 ) m . c1 = aml . Constraint ( expr = m . x [ 0 ] - 2 * m . y [ 0 ] >= 0 ) m . c2 = aml . Constraint ( expr = m . x [ 0 ] - m . x [ 1 ] - 3 * ( 1 - m . y [ 0 ]) <= 0 ) m . c3 = aml . Constraint ( expr = m . x [ 0 ] - ( 1 - m . y [ 0 ]) >= 0 ) m . c4 = aml . Constraint ( expr = m . x [ 1 ] - m . y [ 1 ] >= 0 ) m . c5 = aml . Constraint ( expr = m . x [ 0 ] + m . x [ 1 ] >= 3 * m . y [ 0 ]) m . c6 = aml . Constraint ( expr = m . y [ 0 ] + m . y [ 1 ] >= 1 ) we run galini dot to obtain a .dot file galini dot problem.py problem.dot and we compile it to visualize the DAG dot -T png -o problem.png problem.dot","title":"dot"},{"location":"commands/dot/#dot-command","text":"GALINI provides a command to output a problem DAG to Graphviz DOT files. This is useful when debugging code that needs to traverse the DAG.","title":"dot command"},{"location":"commands/dot/#usage","text":"galini dot [-h] problem [out]","title":"Usage"},{"location":"commands/dot/#example","text":"Given the following input file problem.py import pyomo.environ as aml def get_pyomo_model (): m = aml . ConcreteModel () m . x = aml . Var ( range ( 2 ), bounds = ( 0 , 4.0 )) m . y = aml . Var ( range ( 2 ), bounds = ( 0 , 1 ), domain = aml . Integers ) m . obj = aml . Objective ( expr = m . y [ 0 ] + m . y [ 1 ] + m . x [ 0 ] ** 2 + m . x [ 1 ] ** 2 ) m . c0 = aml . Constraint ( expr = ( m . x [ 0 ] - 2 ) ** 2 - m . x [ 1 ] <= 0 ) m . c1 = aml . Constraint ( expr = m . x [ 0 ] - 2 * m . y [ 0 ] >= 0 ) m . c2 = aml . Constraint ( expr = m . x [ 0 ] - m . x [ 1 ] - 3 * ( 1 - m . y [ 0 ]) <= 0 ) m . c3 = aml . Constraint ( expr = m . x [ 0 ] - ( 1 - m . y [ 0 ]) >= 0 ) m . c4 = aml . Constraint ( expr = m . x [ 1 ] - m . y [ 1 ] >= 0 ) m . c5 = aml . Constraint ( expr = m . x [ 0 ] + m . x [ 1 ] >= 3 * m . y [ 0 ]) m . c6 = aml . Constraint ( expr = m . y [ 0 ] + m . y [ 1 ] >= 1 ) we run galini dot to obtain a .dot file galini dot problem.py problem.dot and we compile it to visualize the DAG dot -T png -o problem.png problem.dot","title":"Example"},{"location":"commands/plugins/","text":"plugins command \u00b6 Prints registered plugins by type. Currently available plugins type: solvers Usage \u00b6 usage: galini plugins [-h] [--format {text,json}] {solvers} galini plugins: error: the following arguments are required: selection Example \u00b6 ID Name Description =================================================================== ipopt ipopt NLP solver. oa outer_approximation Outer-Approximation for convex MINLP.","title":"plugins"},{"location":"commands/plugins/#plugins-command","text":"Prints registered plugins by type. Currently available plugins type: solvers","title":"plugins command"},{"location":"commands/plugins/#usage","text":"usage: galini plugins [-h] [--format {text,json}] {solvers} galini plugins: error: the following arguments are required: selection","title":"Usage"},{"location":"commands/plugins/#example","text":"ID Name Description =================================================================== ipopt ipopt NLP solver. oa outer_approximation Outer-Approximation for convex MINLP.","title":"Example"},{"location":"commands/special_structure/","text":"special_structure command \u00b6 This command can be used to run the special structure detection rules implemented by SUSPECT . Usage \u00b6 galini special_structure [-h] problem Example \u00b6 Given the following input file problem.py import pyomo.environ as aml def get_pyomo_model (): m = aml . ConcreteModel () m . x = aml . Var ( range ( 2 ), bounds = ( 0 , 4.0 )) m . y = aml . Var ( range ( 2 ), bounds = ( 0 , 1 ), domain = aml . Integers ) m . obj = aml . Objective ( expr = m . y [ 0 ] + m . y [ 1 ] + m . x [ 0 ] ** 2 + m . x [ 1 ] ** 2 ) m . c0 = aml . Constraint ( expr = ( m . x [ 0 ] - 2 ) ** 2 - m . x [ 1 ] <= 0 ) m . c1 = aml . Constraint ( expr = m . x [ 0 ] - 2 * m . y [ 0 ] >= 0 ) m . c2 = aml . Constraint ( expr = m . x [ 0 ] - m . x [ 1 ] - 3 * ( 1 - m . y [ 0 ]) <= 0 ) m . c3 = aml . Constraint ( expr = m . x [ 0 ] - ( 1 - m . y [ 0 ]) >= 0 ) m . c4 = aml . Constraint ( expr = m . x [ 1 ] - m . y [ 1 ] >= 0 ) m . c5 = aml . Constraint ( expr = m . x [ 0 ] + m . x [ 1 ] >= 3 * m . y [ 0 ]) m . c6 = aml . Constraint ( expr = m . y [ 0 ] + m . y [ 1 ] >= 1 ) we run galini special_structure and obtain the following output: Var. Dom. LB UB =========================== x[0] R 0.000 4.000 x[1] R 0.000 4.000 y[0] I 0.000 1.000 y[1] I 0.000 1.000 Obj. LB UB Cvx Mono ====================================== obj 0.000 inf Convex Nondecr. Cons. LB UB Cvx Mono ========================================== c0 -4.000 inf Convex c1 -2.000 4.000 Linear c2 -7.000 4.000 Linear c3 -1.000 4.000 Linear Nondecr. c4 -1.000 4.000 Linear c5 -8.000 3.000 Linear c6 0.000 2.000 Linear Nondecr.","title":"special_structure"},{"location":"commands/special_structure/#special_structure-command","text":"This command can be used to run the special structure detection rules implemented by SUSPECT .","title":"special_structure command"},{"location":"commands/special_structure/#usage","text":"galini special_structure [-h] problem","title":"Usage"},{"location":"commands/special_structure/#example","text":"Given the following input file problem.py import pyomo.environ as aml def get_pyomo_model (): m = aml . ConcreteModel () m . x = aml . Var ( range ( 2 ), bounds = ( 0 , 4.0 )) m . y = aml . Var ( range ( 2 ), bounds = ( 0 , 1 ), domain = aml . Integers ) m . obj = aml . Objective ( expr = m . y [ 0 ] + m . y [ 1 ] + m . x [ 0 ] ** 2 + m . x [ 1 ] ** 2 ) m . c0 = aml . Constraint ( expr = ( m . x [ 0 ] - 2 ) ** 2 - m . x [ 1 ] <= 0 ) m . c1 = aml . Constraint ( expr = m . x [ 0 ] - 2 * m . y [ 0 ] >= 0 ) m . c2 = aml . Constraint ( expr = m . x [ 0 ] - m . x [ 1 ] - 3 * ( 1 - m . y [ 0 ]) <= 0 ) m . c3 = aml . Constraint ( expr = m . x [ 0 ] - ( 1 - m . y [ 0 ]) >= 0 ) m . c4 = aml . Constraint ( expr = m . x [ 1 ] - m . y [ 1 ] >= 0 ) m . c5 = aml . Constraint ( expr = m . x [ 0 ] + m . x [ 1 ] >= 3 * m . y [ 0 ]) m . c6 = aml . Constraint ( expr = m . y [ 0 ] + m . y [ 1 ] >= 1 ) we run galini special_structure and obtain the following output: Var. Dom. LB UB =========================== x[0] R 0.000 4.000 x[1] R 0.000 4.000 y[0] I 0.000 1.000 y[1] I 0.000 1.000 Obj. LB UB Cvx Mono ====================================== obj 0.000 inf Convex Nondecr. Cons. LB UB Cvx Mono ========================================== c0 -4.000 inf Convex c1 -2.000 4.000 Linear c2 -7.000 4.000 Linear c3 -1.000 4.000 Linear Nondecr. c4 -1.000 4.000 Linear c5 -8.000 3.000 Linear c6 0.000 2.000 Linear Nondecr.","title":"Example"}]}