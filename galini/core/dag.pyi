# Copyright 2018 Francesco Ceccon
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# pylint: skip-file
from typing import Dict, Any, Iterable, Optional

float_ = float

class Domain(Any): ...
class Sense(Any): ...


class Expression(Any):
    num_children: int
    idx: int
    def nth_children(self, i: int) -> int: ...


class UnaryExpression(Expression): ...
class BinaryExpression(Expression): ...
class NaryExpression(Expression): ...
class ProductExpression(BinaryExpression): ...
class DivisionExpression(BinaryExpression): ...
class SumExpression(NaryExpression): ...
class PowExpression(BinaryExpression): ...
class LinearExpression(NaryExpression):
    constant: float
class UnaryFunctionExpression(UnaryExpression):
    funct_name: str
class NegationExpression(UnaryFunctionExpression): ...
class AbsExpression(UnaryFunctionExpression): ...
class SqrtExpression(UnaryFunctionExpression): ...
class ExpExpression(UnaryFunctionExpression): ...
class LogExpression(UnaryFunctionExpression): ...
class SinExpression(UnaryFunctionExpression): ...
class CosExpression(UnaryFunctionExpression): ...
class TanExpression(UnaryFunctionExpression): ...
class AsinExpression(UnaryFunctionExpression): ...
class AcosExpression(UnaryFunctionExpression): ...
class AtanExpression(UnaryFunctionExpression): ...


class Objective(Any):
    sense: Sense
    root_expr: Expression
    def is_minimizing(self) -> bool: ...
    def is_maximizinig(self) -> bool: ...


class Constraint(Any):
    lower_bound: Optional[float]
    upper_bound: Optional[float]
    root_expr: Expression

    def is_equality(self) -> bool: ...


class Variable(Expression):
    domain: Domain
    lower_bound: Any
    upper_bound: Any
    starting_point: float
    has_starting_point: bool

    def is_binary(self) -> bool: ...
    def is_integer(self) -> bool: ...
    def is_real(self) -> bool: ...
    def set_starting_point(self, point: float) -> None: ...
    def fix(self, point: float) -> None: ...


class Constant(Expression):
    value: float


class Problem(Any):
    name: str
    size: int
    num_variables: int
    num_constraints: int
    num_objectives: int

    def max_depth(self) -> int: ...
    def vertex_depth(self, i: int) -> int: ...
    def add_variable(self, name: str, lower_bound: Any, upper_bound: Any, domain: Domain) -> Variable: ...
    def variable(self, name: str) -> Variable: ...
    @property
    def variables(self) -> Dict[str, Variable]: ...
    def add_constraint(self, name: str, root_expr: Expression, lower_bound: Any, upper_bound: Any) -> Constraint: ...
    def constraint(self, name: str) -> Constraint: ...
    @property
    def constraints(self) -> Dict[str, Constraint]: ...
    def add_objective(self, name: str, root_expr: Expression, sense: Sense) -> Objective: ...
    def objective(self, name: str) -> Objective: ...
    @property
    def objectives(self) -> Dict[str, Objective]: ...
    def insert_vertex(self, expr: Expression) -> int: ...
    def first_child(self, expr: Expression) -> int: ...
    def second_child(self, expr: Expression) -> int: ...
    def nth_child(self, expr: Expression, i: int) -> int: ...
    def sorted_vertices(self) -> Iterable[Expression]: ...
